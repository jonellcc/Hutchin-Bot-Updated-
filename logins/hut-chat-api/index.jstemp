"use strict";
const utils = require("./utils");
const fs = require("fs");
const cron = require("node-cron");
const humanize = require("humanize-ms");
const randomInterval = require("random-interval");
const HttpsProxyAgent = require('https-proxy-agent');

let globalOptions = {};
let ctx = null;
let _defaultFuncs = null;
let api = null;
let region;
let isOnline = false;
let activityInterval;
let humanActivityInterval;
let loginAttempts = 0;
const MAX_LOGIN_ATTEMPTS = 3;

const errorRetrieving = "Error retrieving userID. This can be caused by many factors, including being blocked by Facebook for logging in from an unknown location. Try logging in with a browser to verify.";

const headers = {
	
    'User-Agent': 'Mozilla/5.0 (compatible; MSIE 11.0; Windows NT 6.3; Trident/7.0; Android 8.1.0; SM-G960F)',
	'Accept-Language': 'en-US,en;q=0.9',
	'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
	'Referer': 'https://www.facebook.com/',
	'Sec-Fetch-Mode': 'navigate',
	'Sec-Fetch-Site': 'same-origin',
	'Sec-Fetch-User': '?1',
	'Upgrade-Insecure-Requests': '1',
	'Connection': 'keep-alive'
};

const proxyConfig = {
	host: '203.177.237.138',
	port: 8080,
	protocol: 'http',
	anonymity: 'Transparent'
};

const proxyAgent = new HttpsProxyAgent(`http://${proxyConfig.host}:${proxyConfig.port}`);

const HUMAN_USER_AGENTS = [
	'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
];

const HUMAN_ACTIVITIES = [
	{action: 'scroll', minDelay: 2000, maxDelay: 10000},
	{action: 'pause', minDelay: 30000, maxDelay: 120000},
	{action: 'click', minDelay: 1000, maxDelay: 5000}
];

function cleanupIntervals() {
	if (activityInterval) clearInterval(activityInterval);
	if (humanActivityInterval) clearInterval(humanActivityInterval);
	activityInterval = null;
	humanActivityInterval = null;
}

async function setOptions(globalOptions_from, options = {}) {
	cleanupIntervals();

	Object.keys(options).forEach((key) => {
		switch (key) {
			case 'online':
				globalOptions_from.online = Boolean(options.online);
				if (globalOptions_from.online) startOnlinePresence();
				break;
			case 'selfListen':
				globalOptions_from.selfListen = Boolean(options.selfListen);
				break;
			case 'selfListenEvent':
				globalOptions_from.selfListenEvent = options.selfListenEvent;
				break;
			case 'listenEvents':
				globalOptions_from.listenEvents = Boolean(options.listenEvents);
				break;
			case 'pageID':
				globalOptions_from.pageID = options.pageID.toString();
				break;
			case 'updatePresence':
				globalOptions_from.updatePresence = Boolean(options.updatePresence);
				break;
			case 'forceLogin':
				globalOptions_from.forceLogin = Boolean(options.forceLogin);
				break;
			case 'userAgent':
				globalOptions_from.userAgent = options.userAgent;
				break;
			case 'autoMarkDelivery':
				globalOptions_from.autoMarkDelivery = Boolean(options.autoMarkDelivery);
				break;
			case 'autoMarkRead':
				globalOptions_from.autoMarkRead = Boolean(options.autoMarkRead);
				break;
			case 'listenTyping':
				globalOptions_from.listenTyping = Boolean(options.listenTyping);
				break;
			case 'autoReconnect':
				globalOptions_from.autoReconnect = Boolean(options.autoReconnect);
				break;
			case 'emitReady':
				globalOptions_from.emitReady = Boolean(options.emitReady);
				break;
			case 'randomUserAgent':
				globalOptions_from.randomUserAgent = Boolean(options.randomUserAgent);
				if (globalOptions_from.randomUserAgent) {
					globalOptions_from.userAgent = HUMAN_USER_AGENTS[Math.floor(Math.random() * HUMAN_USER_AGENTS.length)];
				}
				break;
			case 'bypassRegion':
				globalOptions_from.bypassRegion = options.bypassRegion;
				break;
			case 'humanLike':
				globalOptions_from.humanLike = Boolean(options.humanLike);
				if (globalOptions_from.humanLike) startHumanActivity();
				break;
			case 'useProxy':
				globalOptions_from.useProxy = Boolean(options.useProxy);
				break;
		}
	});

	globalOptions = globalOptions_from;
}

function startOnlinePresence() {
	cleanupIntervals();

	activityInterval = setInterval(async () => {
		if (api && api.markOnline) {
			try {
				await api.markOnline();
				isOnline = true;
			} catch (err) {
				utils.error("Failed to maintain online status:", err);
				isOnline = false;
				if (globalOptions.autoReconnect) checkAndReconnect();
			}
		}
	}, randomInterval(45000, 120000));
}

function startHumanActivity() {
	humanActivityInterval = setInterval(async () => {
		if (!api) return;

		const activity = HUMAN_ACTIVITIES[Math.floor(Math.random() * HUMAN_ACTIVITIES.length)];

		try {
			switch(activity.action) {
				case 'scroll':
					await api.simulateScroll();
					break;
				case 'type':
					await api.simulateTyping();
					break;
				case 'click':
					await api.simulateClick();
					break;
			}
		} catch (err) {
			utils.error(`${activity.action} simulation failed:`, err);
		}
	}, randomInterval(30000, 300000));
}

async function checkAndReconnect() {
	if (loginAttempts >= MAX_LOGIN_ATTEMPTS) {
		utils.error("Max login attempts reached. Please check your credentials or account status.");
		return;
	}

	loginAttempts++;
	const delay = randomInterval(5000, 30000);
	utils.warn(`Attempting to reconnect in ${humanize(delay)} (attempt ${loginAttempts}/${MAX_LOGIN_ATTEMPTS})...`);

	setTimeout(async () => {
		try {
			if (globalOptions.email && globalOptions.password) {
				utils.log("Attempting auto-reconnect with credentials...");
				await new Promise((resolve, reject) => {
					loginHelper(null, globalOptions.email, globalOptions.password, api.ws3, (err, newApi) => {
						if (err) return reject(err);
						api = newApi;
						loginAttempts = 0;
						resolve();
					});
				});
			} else if (api.getAppState) {
				utils.log("Attempting auto-reconnect with saved appState...");
				const appState = api.getAppState();
				await new Promise((resolve, reject) => {
					loginHelper(appState, null, null, api.ws3, (err, newApi) => {
						if (err) return reject(err);
						api = newApi;
						loginAttempts = 0;
						resolve();
					});
				});
			}
			utils.log("Auto-reconnect successful!");
		} catch (err) {
			utils.error("Auto-reconnect failed:", err);
			checkAndReconnect();
		}
	}, delay);
}

async function updateDTSG(res, appstate, userId) {
	try {
		const appstateCUser = appstate.find(i => i.key === 'i_user') || appstate.find(i => i.key === 'c_user');
		const UID = userId || appstateCUser.value;

		if (!res?.body) throw new Error("Invalid response: Response body is missing.");

		const fb_dtsg = utils.getFrom(res.body, '["DTSGInitData",[],{"token":"', '","');
		const jazoest = utils.getFrom(res.body, 'jazoest=', '",');

		if (fb_dtsg && jazoest) {
			const filePath = 'fb_dtsg_data.json';
			let existingData = {};

			if (fs.existsSync(filePath)) {
				existingData = JSON.parse(fs.readFileSync(filePath, 'utf8'));
			}

			existingData[UID] = { fb_dtsg, jazoest, lastUpdated: new Date().toISOString() };
			fs.writeFileSync(filePath, JSON.stringify(existingData, null, 2), 'utf8');
		}
		return res;
	} catch (error) {
		utils.error(`Error updating DTSG: ${error.message}`);
		return null;
	}
}

async function bypassAutoBehavior(resp, jar, appstate, ID) {
	try {
		const appstateCUser = appstate.find(i => i.key === 'c_user') || appstate.find(i => i.key === 'i_user');
		const UID = ID || appstateCUser.value;

		if (resp?.request?.uri?.href?.includes("https://www.facebook.com/checkpoint/601051028565049")) {
			const fb_dtsg = utils.getFrom(resp.body, '["DTSGInitData",[],{"token":"', '","');
			const jazoest = utils.getFrom(resp.body, 'jazoest=', '",');
			const lsd = utils.getFrom(resp.body, "[\"LSD\",[],{\"token\":\"", "\"}");

			const FormBypass = {
				av: UID,
				fb_api_caller_class: "RelayModern",
				fb_api_req_friendly_name: "FBScrapingWarningMutation",
				variables: JSON.stringify({}),
				server_timestamps: true,
				doc_id: 6339492849481770,
				fb_dtsg,
				jazoest,
				lsd
			};

			const requestOptions = {
				headers: headers,
				agent: globalOptions.useProxy ? proxyAgent : null
			};

			return utils.post("https://www.facebook.com/api/graphql/", jar, FormBypass, requestOptions)
				.then(utils.saveCookies(jar))
				.then(res => {
					utils.warn(`Detected automated behavior on account ${UID}. This may cause auto logout.`);
					return res;
				});
		}
		return resp;
	} catch (e) {
		utils.error("Bypass error:", e);
		return resp;
	}
}

async function checkAccountStatus(resp, appstate) {
	try {
		const appstateCUser = appstate.find(i => i.key === 'c_user') || appstate.find(i => i.key === 'i_user');
		const UID = appstateCUser?.value;

		if (resp?.request?.uri?.href?.includes("https://www.facebook.com/checkpoint/")) {
			if (resp.request.uri.href.includes('1501092823525282')) {
				const status = { suspended: true, reasons: {} };
				const daysMatch = resp.body?.match(/"log_out_uri":"(.*?)","title":"(.*?)"/);
				const reasonMatch = resp.body?.match(/"reason_section_body":"(.*?)"/);

				if (daysMatch?.[2]) status.reasons.duration = daysMatch[2];
				if (reasonMatch?.[1]) {
					status.reasons.long = reasonMatch[1];
					const short = reasonMatch[1].toLowerCase()
						.replace("your account, or activity on it, doesn't follow our community standards on ", "");
					status.reasons.short = short.charAt(0).toUpperCase() + short.slice(1);
				}

				utils.error(`Account ${UID} suspended!`, status.reasons);
				return status;
			}

			if (resp.request.uri.href.includes('828281030927956')) {
				const lockMatch = resp.body.match(/"is_unvetted_flow":true,"title":"(.*?)"/);
				const status = { locked: true, reason: lockMatch?.[1] || "Unknown reason" };
				utils.error(`Account ${UID} locked:`, status.reason);
				return status;
			}
		}
		return null;
	} catch (e) {
		utils.error("Status check error:", e);
		return null;
	}
}

function buildAPI(html, jar) {
	const tokenMatch = html.match(/DTSGInitialData.*?token":"(.*?)"/);
	const fb_dtsg = tokenMatch?.[1];

	const cookies = jar.getCookies("https://www.facebook.com");
	const userCookie = cookies.find(c => ['c_user', 'i_user'].includes(c.key));

	if (!userCookie) throw { error: errorRetrieving };
	if (html.includes("/checkpoint/block/?next")) {
		throw { error: "Checkpoint detected. Please log in with a browser to verify." };
	}

	const userID = userCookie.value.toString();
	utils.log("Logged in successfully!");

	const clientID = (Math.random() * 2147483648 | 0).toString(16);
	const CHECK_MQTT = {
		oldFBMQTTMatch: html.match(/irisSeqID:"(.+?)",appID:219994525426954,endpoint:"(.+?)"/),
		newFBMQTTMatch: html.match(/{"app_id":"219994525426954","endpoint":"(.+?)","iris_seq_id":"(.+?)"}/),
		legacyFBMQTTMatch: html.match(/\["MqttWebConfig",\[\],{"fbid":"(.*?)","appID":219994525426954,"endpoint":"(.*?)","pollingEndpoint":"(.*?)"/)
	};

	let mqttEndpoint, irisSeqID;

	for (const [type, match] of Object.entries(CHECK_MQTT)) {
		if (!globalOptions.bypassRegion && match && !region) {
			if (type === 'oldFBMQTTMatch') {
				irisSeqID = match[1];
				mqttEndpoint = match[2].replace(/\\\//g, "/");
			} else if (type === 'newFBMQTTMatch') {
				irisSeqID = match[2];
				mqttEndpoint = match[1].replace(/\\\//g, "/");
			} else if (type === 'legacyFBMQTTMatch') {
				mqttEndpoint = match[2].replace(/\\\//g, "/");
			}

			if (mqttEndpoint) {
				try {
					region = new URL(mqttEndpoint).searchParams.get("region")?.toUpperCase();
				} catch (e) {
					utils.error("Failed to parse MQTT endpoint:", e);
				}
			}
		}
	}

	region = globalOptions.bypassRegion?.toUpperCase() || region || 
		["prn", "pnb", "vll", "hkg", "sin", "ftw", "ash"][Math.floor(Math.random() * 7)].toUpperCase();

	mqttEndpoint = mqttEndpoint ||`wss//edge-chat.messenger.com/chat?region=${region}`;

	const ctx = {
		userID,
		jar,
		clientID,
		globalOptions,
		loggedIn: true,
		access_token: 'NONE',
		clientMutationId: 0,
		mqttClient: undefined,
		lastSeqId: irisSeqID,
		syncToken: undefined,
		mqttEndpoint,
		wsReqNumber: 0,
		wsTaskNumber: 0,
		reqCallbacks: {},
		region,
		firstListen: true,
		fb_dtsg
	};

	scheduleDTSGRefresh(userID);

	const defaultFuncs = utils.makeDefaults(html, userID, ctx);
	return [ctx, defaultFuncs];
}

function scheduleDTSGRefresh(userID) {
	const randomHour = Math.floor(Math.random() * 24);
	const randomMinute = Math.floor(Math.random() * 60);

	cron.schedule(`${randomMinute} ${randomHour} * * *`, () => {
		try {
			const fbDtsgData = JSON.parse(fs.readFileSync('fb_dtsg_data.json', 'utf8'));
			if (fbDtsgData?.[userID]) {
				api.refreshFb_dtsg(fbDtsgData[userID])
					.then(() => utils.log(`Refreshed fb_dtsg for user ${userID}`))
					.catch(err => utils.error(`fb_dtsg refresh failed:`, err));
			}
		} catch (err) {
			utils.error("DTSG refresh error:", err);
		}
	}, {
		timezone: 'Asia/Manila',
		name: 'dtsg-refresh'
	});
}

async function loginHelper(appState, email, password, apiCustomized = {}, callback) {
	const jar = utils.getJar();
	utils.log('Starting login process...');

	if (email && password) {
		globalOptions.email = email;
		globalOptions.password = password;
	}

	let mainPromise;

	if (appState) {
		appState = normalizeAppState(appState);
		setCookiesFromAppState(jar, appState);
		const requestOptions = {
			headers: headers,
			agent: globalOptions.useProxy ? proxyAgent : null,
			noRef: true
		};
		mainPromise = utils.get('https://www.facebook.com/', jar, null, requestOptions)
			.then(utils.saveCookies(jar));
	} else if (email && password) {
		mainPromise = handleCredentialLogin(jar, email, password);
	} else {
		return callback({ error: "Please provide either appState or credentials." });
	}

	initializeAPI(jar);

	mainPromise
		.then(res => bypassAutoBehavior(res, jar, appState || []))
		.then(res => updateDTSG(res, appState || []))
		.then(async (res) => {
			const requestOptions = {
				headers: headers,
				agent: globalOptions.useProxy ? proxyAgent : null
			};
			const html = (await utils.get(`https://www.facebook.com/home.php`, jar, null, requestOptions))?.body;
			const [ctx, defaultFuncs] = buildAPI(html, jar);

			setupAPI(ctx, defaultFuncs, apiCustomized);
			await verifyLogin(ctx);

			if (globalOptions.online) startOnlinePresence();
			if (globalOptions.humanLike) startHumanActivity();

			callback(null, api);
		})
		.catch(async (err) => {
			const status = await checkAccountStatus(err.response, appState || []);
			if (status) callback(status);
			else if (isBehavior) {
				utils.warn("Behavior detection triggered, attempting reconnect...");
				setTimeout(() => checkAndReconnect(), randomInterval(5000, 15000));
				callback(err);
			} else {
				callback(err);
			}
		});
}

function normalizeAppState(appState) {
	if (Array.isArray(appState) && appState.some(c => c.name)) {
		return appState.map(c => ({ ...c, key: c.name }));
	}

	if (typeof appState === 'string') {
		return appState.split(';').map(c => {
			const [key, value] = c.split('=');
			return {
				key: (key || "").trim(),
				value: (value || "").trim(),
				domain: ".facebook.com",
				path: "/",
				expires: Date.now() + 1000 * 60 * 60 * 24 * 365
			};
		});
	}

	return appState;
}

function setCookiesFromAppState(jar, appState) {
	appState.forEach(c => {
		jar.setCookie(
			`${c.key}=${c.value}; expires=${new Date(c.expires).toUTCString()}; domain=${c.domain}; path=${c.path};`,
			`http://${c.domain}`
		);
	});
}

async function handleCredentialLogin(jar, email, password) {
	const requestOptions = {
		headers: headers,
		agent: globalOptions.useProxy ? proxyAgent : null
	};

	const loginRes = await utils.post('https://www.facebook.com/login.php', jar, {
		email,
		pass: password,
		login: "Log In"
	}, requestOptions);

	utils.saveCookies(jar)(loginRes);

	if (loginRes.headers.location?.includes('checkpoint')) {
		throw { error: "Checkpoint detected. Please login via browser first." };
	}

	return utils.get('https://www.facebook.com/', jar, null, requestOptions);
}

function initializeAPI(jar) {
	api = {
		setOptions: setOptions.bind(null, globalOptions),
		getAppState: () => {
			const appState = utils.getAppState(jar);
			return Array.isArray(appState) ? 
				appState.filter((item, index, self) => 
					self.findIndex(t => t.key === item.key) === index
				) : [];
		},
		simulateScroll: () => {
			const requestOptions = {
				headers: headers,
				agent: globalOptions.useProxy ? proxyAgent : null
			};
			return utils.get('https://www.facebook.com/', jar, null, requestOptions);
		},
		simulateTyping: () => {
			const requestOptions = {
				headers: headers,
				agent: globalOptions.useProxy ? proxyAgent : null
			};
			return utils.post('https://www.facebook.com/ajax/typeahead/search.php', jar, {
				__a: 1,
				__user: ctx?.userID,
				fb_dtsg: ctx?.fb_dtsg,
				value: String.fromCharCode(97 + Math.floor(Math.random() * 26)),
				viewer: ctx?.userID,
				rsp: "search",
				context: "search",
				path: "/",
				request_id: utils.generateRequestId()
			}, requestOptions);
		},
		simulateClick: () => {
			const pages = ['notifications', 'messages', 'events'];
			const requestOptions = {
				headers: headers,
				agent: globalOptions.useProxy ? proxyAgent : null
			};
			return utils.get(`https://www.facebook.com/${pages[Math.floor(Math.random() * pages.length)]}`, jar, null, requestOptions);
		},
		markOnline: () => {
			const requestOptions = {
				headers: headers,
				agent: globalOptions.useProxy ? proxyAgent : null
			};
			return utils.post('https://www.facebook.com/ajax/chat/status.php', jar, {
				__a: 1,
				__user: ctx?.userID,
				fb_dtsg: ctx?.fb_dtsg,
				status: 'active'
			}, requestOptions);
		},
		jar: jar
	};
}

function setupAPI(ctx, defaultFuncs, apiCustomized) {
	api.addFunctions = (directory) => {
		const folder = directory.endsWith("/") ? directory : `${directory}/`;
		fs.readdirSync(folder)
			.filter(v => v.endsWith('.js'))
			.forEach(v => {
				api[v.replace('.js', '')] = require(`${folder}${v}`)(defaultFuncs, api, ctx);
			});
	};

	api.addFunctions(`${__dirname}/src`);
	api.listen = api.listenMqtt;
	api.ws3 = {
		...apiCustomized,
		relogin: () => {
			loginAttempts = 0;
			checkAndReconnect();
		}
	};
}

async function verifyLogin(ctx) {
	try {
		const bi = await api.getBotInitialData();
		if (!bi.error) {
			utils.log(`Logged in as ${bi.name} (ID: ${bi.uid})`);
			ctx.userName = bi.name;
		} else {
			utils.warn(`Failed to fetch full account info, using ID ${ctx.userID}`);
		}
		utils.log(`Connected to ${ctx.region || "UNKNOWN"} region`);
	} catch (err) {
		utils.warn("Account verification failed:", err);
	}
}

async function login(loginData, options, callback) {
	if (typeof options === 'function') {
		callback = options;
		options = {};
	}

	const defaultOptions = {
		selfListen: false,
		listenEvents: true,
		autoMarkRead: true,
		autoReconnect: true,
		online: true,
		randomUserAgent: true,
		humanLike: true,
		useProxy: true,
		userAgent: headers['User-Agent']
	};

	try {
		await setOptions({ ...defaultOptions, ...options }, options);

		loginHelper(
			loginData?.appState, 
			loginData?.email, 
			loginData?.password, 
			{ relogin: () => login(loginData, options, callback) },
			callback
		);
	} catch (err) {
		callback(err);
	}
}

module.exports = login;